{"version":3,"sources":["2d_array.md"],"names":[],"mappings":"AAkBC,MAAA,IAAA,GAAA,CACA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,CADA,EAEA,CAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,CAFA,EAGA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,EAAA,CAAA,CAAA,IAAA,EAAA,EAAA,GAAA,CAAA,KAAA,IAAA,KAAA,GAAA,CAAA,KAAA,CAAA,CAHA,CAAA;AA+CA,OAAA,SAAA,YAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA;AACA,SAAA;AACA,IAAA,QAAA,EAAA,IAAA,CAAA,CAAA,CAAA,CAAA,MADA;AAEA,IAAA,WAAA,EAAA,IAAA,CAAA,MAFA;AAGA,IAAA,IAAA,EAAA,IAAA,CAAA,KAAA,CAAA,EAAA,EAAA,EAAA,EAAA,GAAA,CAAA,GAAA,IAAA,GAAA,CAAA,KAAA,CAAA,EAAA,EAAA,EAAA,CAAA;AAHA,GAAA;AAKA;AAMA,OAAA,SAAA,IAAA,GAAA;AACA,EAAA,MAAA,CAAA,YAAA,CAAA,eAAA,CAAA,YAAA;AACA,EAAA,MAAA,CAAA,YAAA,CAAA,IAAA;AACA","sourcesContent":["# Simple Example\n\nYou'll need to create a `<regular-table>`.  The easiest way is to just add one\ndirectly to your page's HTML, and we'll give it an `id` attribute to refer to it\neasily later.  Fun fact - elements with `id` attributes are accessible on the\nglobal `window` Object in Javascript via `window.${id}`, at least [maybe](https://stackoverflow.com/questions/18713272/why-do-dom-elements-exist-as-properties-on-the-window-object).\n\n```html\n<regular-table id=\"regularTable\"></regular-table>\n```\n\nLet's start with with a simple data model, a two dimensional `Array`.  This one\nis very small at 3 columns x 26 rows, but even for very small data sets,\n`regular-table` won't read your entire dataset at once.  Instead, we'll need\nto write a simple _virtual_ data model to access `DATA` and `COLUMN_NAMES`\nindirectly.\n\n```javascript\nconst DATA = [\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],\n    [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\"],\n    Array.from(Array(15).keys()).map((value) => value % 2 === 0),\n];\n```\n\nWhen clipped by the scrollable viewport, you may end up with a `<table>` of just\na rectangular region of `DATA`, rather than the entire set.  A simple viewport\n2x2 may yield this `<table>`:\n\n<table>\n<tbody>\n<tr>\n<td>0</td>\n<td>A</td>\n</tr>\n<tr>\n<td>1</td>\n<td>B</td>\n</tr>\n</tbody>\n</table>\n\n```json\n{\n    \"num_rows\": 15,\n    \"num_columns\": 3,\n    \"data\": [\n        [0, 1],\n        [\"A\", \"B\"]\n    ]\n}\n```\n\nHere's a an implementation for this simple _virtual_ data model,\nthe function `dataListener()`.  This function is called by your \n`<regular-table>` whenever it needs more data, with coordinate arguments,\n`(x0, y0)` to `(x1, y1)`.  Only this region is needed to render the viewport,\nso `dataListener()` returns this rectangular `slice` of `DATA`.  For the window\n(0, 0) to (2, 2), `dataListener()` would generate an Object as above,\ncontaining the `data` slice, as well as the overall dimensions of `DATA` itself\n( `num_rows`, `num_columns`), for sizing the scroll area.  To render this\nvirtual data model to a regular HTML `<table>`, register this data model via\nthe `setDataListener()` method:\n\n```javascript\nexport function dataListener(x0, y0, x1, y1) {\n    return {\n        num_rows: DATA[0].length,\n        num_columns: DATA.length,\n        data: DATA.slice(x0, x1).map((col) => col.slice(y0, y1)),\n    };\n}\n```\n\nYou can register and invoke this table thusly:\n\n```javascript\nexport function init() {\n    window.regularTable.setDataListener(dataListener);\n    window.regularTable.draw();\n}\n```\n\n... which we'll do on the Window `\"load\"` event.\n\n```html\n<script type=\"module\">\n    import {init} from \"/dist/examples/2d_array.js\";\n    window.addEventListener(\"load\", () => init());\n</script>\n```\n\n# Appendix (Dependencies)\n\n```html\n<script src=\"/dist/umd/regular-table.js\"></script>\n<link rel='stylesheet' href=\"/dist/css/material.css\">\n```\n\n```block\nlicense: apache-2.0\n```\n\n"]}