{"version":3,"sources":["spreadsheet.md"],"names":[],"mappings":"AAaC,MAAA,WAAA,GAAA,GAAA;AACA,MAAA,QAAA,GAAA,IAAA;AAEA,MAAA,IAAA,GAAA,KAAA,CAAA,WAAA,CAAA,CACA,IADA,GAEA,GAFA,CAEA,MAAA,KAAA,CAAA,QAAA,CAAA,CAAA,IAAA,EAFA,CAAA;AAUA,MAAA,iBAAA,GAAA,qBAAA,EAAA;;AAEA,SAAA,qBAAA,GAAA;AACA,QAAA,IAAA,GAAA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,EAAA,CAAA,CAAA;AACA,QAAA,QAAA,GAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,EAAA,CAAA,KAAA,MAAA,CAAA,YAAA,CAAA,CAAA,GAAA,EAAA,CAAA,CAAA;AACA,MAAA,IAAA,GAAA,EAAA;AAAA,MACA,CAAA,GAAA,CADA;;AAEA,SAAA,IAAA,CAAA,MAAA,GAAA,WAAA,EAAA;AACA,IAAA,IAAA,GAAA,IAAA,CAAA,MAAA,CAAA,QAAA,CAAA,GAAA,CAAA,MAAA,IAAA,cAAA,CAAA,CAAA,EAAA,MAAA,CAAA,CAAA,CAAA;AACA,IAAA,CAAA;AACA;;AACA,SAAA,IAAA;AACA;;AAEA,SAAA,cAAA,CAAA,CAAA,EAAA,MAAA,EAAA;AACA,SAAA,KAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,MAAA,EAAA,IAAA,CAAA,EAAA,CAAA;AACA;;AAMA,SAAA,YAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA;AACA,SAAA;AACA,IAAA,QAAA,EAAA,IAAA,CAAA,CAAA,CAAA,CAAA,MADA;AAEA,IAAA,WAAA,EAAA,IAAA,CAAA,MAFA;AAGA,IAAA,WAAA,EAAA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA,IAAA,CAAA,EAAA,IAAA,EAAA,CAAA,CAAA,IAAA,EAAA,EAAA,GAAA,CAAA,CAAA,IAAA,CACA,GAAA,CAAA,GAAA,EAAA,EADA,CAAA,CAHA;AAMA,IAAA,cAAA,EAAA,iBAAA,CAAA,KAAA,CAAA,EAAA,EAAA,EAAA,EAAA,GAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CANA;AAOA,IAAA,IAAA,EAAA,IAAA,CAAA,KAAA,CAAA,EAAA,EAAA,EAAA,EAAA,GAAA,CAAA,GAAA,IAAA,GAAA,CAAA,KAAA,CAAA,EAAA,EAAA,EAAA,CAAA;AAPA,GAAA;AASA;;AAQA,MAAA,KAAA,GAAA,QAAA,CAAA,oBAAA,CAAA,eAAA,EAAA,CAAA,CAAA;AACA,KAAA,CAAA,eAAA,CAAA,YAAA;;AAQA,SAAA,GAAA,CAAA,GAAA,EAAA;AACA,SAAA,IAAA,CAAA,GAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAA,CAAA,KAAA,QAAA,CAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA,CAAA,CAAA;AACA;;AAEA,SAAA,GAAA,CAAA,GAAA,EAAA;AACA,QAAA,CAAA,GAAA,IAAA,CAAA,GAAA,CAAA;AACA,SAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAA,CAAA,KAAA,QAAA,CAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,MAAA;AACA;;AASA,SAAA,SAAA,CAAA,CAAA,EAAA,CAAA,EAAA;AACA,MAAA,GAAA,GAAA,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;AACA,MAAA,GAAA,GAAA,QAAA,CAAA,GAAA,CAAA;;AACA,MAAA,KAAA,CAAA,GAAA,CAAA,EAAA;AACA,IAAA,GAAA,GAAA,GAAA;AACA;;AACA,SAAA,GAAA,GAAA,EAAA;AACA;;AAEA,SAAA,KAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA;AACA,SAAA,IAAA,CAAA,KAAA,CAAA,EAAA,EAAA,QAAA,CAAA,EAAA,CAAA,GAAA,CAAA,EAAA,GAAA,CAAA,CAAA,IACA,CAAA,CAAA,KAAA,CAAA,EAAA,EAAA,QAAA,CAAA,EAAA,CAAA,GAAA,CAAA,CADA,CAAA;AAGA;;AAIA,SAAA,OAAA,CAAA,CAAA,EAAA;AACA,SAAA,iBAAA,CAAA,OAAA,CAAA,CAAA,CAAA;AACA;;AAEA,SAAA,IAAA,CAAA,GAAA,EAAA;AACA,SAAA,GAAA,CACA,IADA,CACA,CADA,EAEA,GAFA,CAEA,CAAA,IAAA,QAAA,CAAA,CAAA,CAFA,EAGA,MAHA,CAGA,CAAA,IAAA,CAAA,KAAA,CAAA,CAAA,CAHA,CAAA;AAIA;;AAOA,MAAA,aAAA,GAAA,wCAAA;AACA,MAAA,YAAA,GAAA,kBAAA;;AAQA,SAAA,OAAA,CAAA,KAAA,EAAA;AACA,QAAA,MAAA,GAAA,KAAA,CACA,KADA,CACA,CADA,EAEA,OAFA,CAGA,IAAA,MAAA,CAAA,aAAA,EAAA,GAAA,CAHA,EAIA,CAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KACA,SAAA,OAAA,CAAA,EAAA,CAAA,KAAA,EAAA,KAAA,OAAA,CAAA,EAAA,CAAA,KAAA,EAAA,GALA,EAOA,OAPA,CAQA,IAAA,MAAA,CAAA,YAAA,EAAA,GAAA,CARA,EASA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,KAAA,aAAA,OAAA,CAAA,CAAA,CAAA,KAAA,CAAA,GATA,CAAA;AAWA,EAAA,OAAA,CAAA,GAAA,CAAA,aAAA,KAAA,SAAA,MAAA,GAAA;AACA,SAAA,IAAA,CAAA,MAAA,CAAA;AACA;;AAOA,MAAA,iBAAA,GAAA;AAAA,EAAA,CAAA,EAAA,CAAA;AAAA,EAAA,CAAA,EAAA;AAAA,CAAA;;AAUA,MAAA,WAAA,GAAA,MAAA;AACA,QAAA,GAAA,GAAA,KAAA,CAAA,gBAAA,CAAA,IAAA,CAAA;;AACA,OAAA,MAAA,EAAA,IAAA,GAAA,EAAA;AACA,UAAA,IAAA,GAAA,KAAA,CAAA,OAAA,CAAA,EAAA,CAAA;;AACA,QAAA,IAAA,CAAA,CAAA,KAAA,iBAAA,CAAA,CAAA,IAAA,IAAA,CAAA,CAAA,KAAA,iBAAA,CAAA,CAAA,EAAA;AACA,MAAA,EAAA,CAAA,KAAA;AACA;AACA;AACA,CARA;;AAUA,KAAA,CAAA,gBAAA,CAAA,OAAA,EAAA,KAAA,IAAA;AACA,QAAA,IAAA,GAAA,KAAA,CAAA,OAAA,CAAA,KAAA,CAAA,MAAA,CAAA;AACA,EAAA,iBAAA,CAAA,CAAA,GAAA,IAAA,CAAA,CAAA;AACA,EAAA,iBAAA,CAAA,CAAA,GAAA,IAAA,CAAA,CAAA;AACA,EAAA,WAAA;AACA,CALA;AAgBA,KAAA,CAAA,gBAAA,CAAA,MAAA;AACA,OAAA,MAAA,EAAA,IAAA,KAAA,CAAA,gBAAA,CAAA,IAAA,CAAA,EAAA;AACA,IAAA,EAAA,CAAA,YAAA,CAAA,iBAAA,EAAA,IAAA;AACA;AACA,CAJA;AAMA,KAAA,CAAA,gBAAA,CAAA,WAAA;AAEA,KAAA,CAAA,IAAA;;AAUA,SAAA,KAAA,CAAA,WAAA,EAAA;AACA,QAAA,IAAA,GAAA,KAAA,CAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,IAAA,EAAA;AACA,QAAA,IAAA,GAAA,WAAA,CAAA,WAAA;;AACA,QAAA,IAAA,CAAA,CAAA,CAAA,KAAA,GAAA,EAAA;AACA,MAAA,IAAA,GAAA,OAAA,CAAA,IAAA,CAAA;AACA;;AACA,IAAA,IAAA,CAAA,IAAA,CAAA,CAAA,CAAA,CAAA,IAAA,CAAA,CAAA,IAAA,IAAA;AACA,IAAA,WAAA,CAAA,IAAA;AACA,IAAA,eAAA;AACA,IAAA,KAAA,CAAA,IAAA;AACA;AACA;;AAQA,KAAA,CAAA,gBAAA,CAAA,UAAA,EAAA,KAAA,IAAA;AACA,QAAA,MAAA,GAAA,QAAA,CAAA,aAAA;;AACA,MAAA,KAAA,CAAA,OAAA,KAAA,EAAA,EAAA;AACA,IAAA,KAAA,CAAA,cAAA;;AACA,QAAA,KAAA,CAAA,QAAA,EAAA;AACA,MAAA,aAAA,CAAA,MAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA;AACA,KAFA,MAEA;AACA,MAAA,aAAA,CAAA,MAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AACA;AACA;AACA,CAVA;AAYA,KAAA,CAAA,gBAAA,CAAA,OAAA,EAAA,KAAA,IAAA;AACA,QAAA,MAAA,GAAA,QAAA,CAAA,aAAA;;AACA,MAAA,KAAA,CAAA,OAAA,KAAA,EAAA,EAAA;AACA,IAAA,SAAA,CAAA,MAAA,CAAA;AACA;AACA,CALA;AAOA,KAAA,CAAA,gBAAA,CAAA,SAAA,EAAA,KAAA,IAAA;AACA,QAAA,MAAA,GAAA,QAAA,CAAA,aAAA;;AACA,UAAA,KAAA,CAAA,OAAA;AACA;AACA,SAAA,CAAA;AACA,MAAA,KAAA,CAAA,cAAA;;AACA,UAAA,KAAA,CAAA,QAAA,EAAA;AACA,QAAA,aAAA,CAAA,MAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA;AACA,OAFA,MAEA;AACA,QAAA,aAAA,CAAA,MAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AACA;;AACA;AACA;;AACA,SAAA,EAAA;AACA,MAAA,aAAA,CAAA,MAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA;AACA;AACA;;AACA,SAAA,EAAA;AACA,MAAA,aAAA,CAAA,MAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA;AACA;AACA;;AACA,SAAA,EAAA;AACA,MAAA,aAAA,CAAA,MAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AACA;AACA;;AACA,SAAA,EAAA;AACA,MAAA,aAAA,CAAA,MAAA,EAAA,CAAA,EAAA,CAAA,CAAA;AACA;AAzBA;AA2BA,CA7BA;AAsCA,MAAA,YAAA,GAAA,CAAA;;AAEA,eAAA,aAAA,CAAA,WAAA,EAAA,EAAA,EAAA,EAAA,EAAA;AACA,QAAA,IAAA,GAAA,KAAA,CAAA,OAAA,CAAA,WAAA,CAAA;;AACA,MAAA,EAAA,KAAA,CAAA,EAAA;AACA,QAAA,IAAA,CAAA,CAAA,GAAA,EAAA,GAAA,WAAA,IAAA,KAAA,IAAA,CAAA,CAAA,GAAA,EAAA,EAAA;AACA,MAAA,iBAAA,CAAA,CAAA,GAAA,IAAA,CAAA,CAAA,GAAA,EAAA;AACA;;AACA,QAAA,IAAA,CAAA,EAAA,IAAA,iBAAA,CAAA,CAAA,GAAA,YAAA,EAAA;AACA,YAAA,KAAA,CAAA,YAAA,CAAA,IAAA,CAAA,EAAA,GAAA,CAAA,EAAA,IAAA,CAAA,EAAA,EAAA,WAAA,EAAA,QAAA,CAAA;AACA,KAFA,MAEA,IAAA,iBAAA,CAAA,CAAA,GAAA,YAAA,GAAA,IAAA,CAAA,EAAA,EAAA;AACA,UAAA,IAAA,IAAA,CAAA,EAAA,GAAA,CAAA,EAAA;AACA,cAAA,KAAA,CAAA,YAAA,CAAA,IAAA,CAAA,EAAA,GAAA,CAAA,EAAA,IAAA,CAAA,EAAA,EAAA,WAAA,EAAA,QAAA,CAAA;AACA,OAFA,MAEA;AACA,cAAA,KAAA,CAAA,YAAA,CAAA,CAAA,EAAA,IAAA,CAAA,EAAA,EAAA,WAAA,EAAA,QAAA,CAAA;AACA;AACA;AACA;;AAEA,MAAA,EAAA,KAAA,CAAA,EAAA;AACA,QAAA,IAAA,CAAA,CAAA,GAAA,EAAA,GAAA,QAAA,IAAA,KAAA,IAAA,CAAA,CAAA,GAAA,EAAA,EAAA;AACA,MAAA,iBAAA,CAAA,CAAA,GAAA,IAAA,CAAA,CAAA,GAAA,EAAA;AACA;;AACA,QAAA,IAAA,CAAA,EAAA,IAAA,iBAAA,CAAA,CAAA,GAAA,YAAA,EAAA;AACA,YAAA,KAAA,CAAA,YAAA,CAAA,IAAA,CAAA,EAAA,EAAA,IAAA,CAAA,EAAA,GAAA,CAAA,EAAA,WAAA,EAAA,QAAA,CAAA;AACA,KAFA,MAEA,IAAA,iBAAA,CAAA,CAAA,GAAA,YAAA,GAAA,CAAA,GAAA,IAAA,CAAA,EAAA,EAAA;AACA,UAAA,IAAA,IAAA,CAAA,EAAA,GAAA,CAAA,EAAA;AACA,cAAA,KAAA,CAAA,YAAA,CAAA,IAAA,CAAA,EAAA,EAAA,IAAA,CAAA,EAAA,GAAA,CAAA,EAAA,WAAA,EAAA,QAAA,CAAA;AACA,OAFA,MAEA;AACA,cAAA,KAAA,CAAA,YAAA,CAAA,IAAA,CAAA,EAAA,EAAA,CAAA,EAAA,WAAA,EAAA,QAAA,CAAA;AACA;AACA;AACA;;AACA,EAAA,WAAA;AACA;;AAUA,KAAA,CAAA,gBAAA,CAAA,QAAA,EAAA,MAAA;AACA,EAAA,KAAA,CAAA,QAAA,CAAA,aAAA,CAAA;AACA,CAFA;AASA,KAAA,CAAA,gBAAA,CAAA,UAAA,EAAA,KAAA,IAAA;AACA,EAAA,KAAA,CAAA,KAAA,CAAA,MAAA,CAAA;AACA,CAFA;;AAeA,eAAA,SAAA,CAAA,WAAA,EAAA;AACA,EAAA,eAAA;AACA,QAAA,IAAA,GAAA,WAAA,CAAA,WAAA;AACA,QAAA,IAAA,GAAA,KAAA,CAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,OAAA,MAAA,CAAA,CAAA,EAAA,CAAA,CAAA,IAAA,SAAA,CAAA,YAAA,EAAA,IAAA,CAAA,EAAA;AACA,IAAA,eAAA,CAAA,CAAA,GAAA,CAAA,EAAA,CAAA,EAAA,IAAA,CAAA;AACA;;AAEA,OAAA,MAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,CAAA,IAAA,SAAA,CAAA,aAAA,EAAA,IAAA,CAAA,EAAA;AACA,SAAA,IAAA,CAAA,GAAA,EAAA,EAAA,CAAA,IAAA,EAAA,EAAA,CAAA,EAAA,EAAA;AACA,WAAA,IAAA,CAAA,GAAA,EAAA,EAAA,CAAA,IAAA,EAAA,EAAA,CAAA,EAAA,EAAA;AACA,QAAA,eAAA,CAAA,CAAA,GAAA,CAAA,EAAA,CAAA,EAAA,IAAA,CAAA;AACA;AACA;AACA;AACA;;AASA,SAAA,eAAA,GAAA;AACA,OAAA,MAAA,EAAA,IAAA,KAAA,CAAA,gBAAA,CAAA,cAAA,CAAA,EAAA;AACA,IAAA,EAAA,CAAA,SAAA,CAAA,MAAA,CAAA,WAAA;AACA;AACA;;AAEA,UAAA,SAAA,CAAA,IAAA,EAAA,IAAA,EAAA;AACA,MAAA,KAAA;AACA,MAAA,KAAA,GAAA,IAAA,MAAA,CAAA,IAAA,EAAA,GAAA,CAAA;;AACA,SAAA,CAAA,KAAA,GAAA,KAAA,CAAA,IAAA,CAAA,IAAA,CAAA,MAAA,IAAA,EAAA;AACA,UAAA,KAAA,CACA,KADA,CACA,CADA,EAEA,GAFA,CAEA,CAAA,CAAA,EAAA,CAAA,KAAA,CAAA,GAAA,CAAA,KAAA,CAAA,GAAA,OAAA,CAAA,CAAA,CAAA,GAAA,QAAA,CAAA,CAAA,CAFA,CAAA;AAGA;AACA;;AAEA,SAAA,eAAA,CAAA,CAAA,EAAA,CAAA,EAAA,IAAA,EAAA;AACA,QAAA,EAAA,GAAA,KAAA,CAAA,aAAA,CAAA,OAAA,EAAA,QAAA,CAAA,CAAA,GAAA,IAAA,CAAA,EAAA,CAAA;AACA,QAAA,EAAA,GAAA,EAAA,CAAA,QAAA,CAAA,CAAA,GAAA,IAAA,CAAA,EAAA,CAAA;AACA,EAAA,EAAA,CAAA,SAAA,CAAA,GAAA,CAAA,WAAA;AACA","sourcesContent":["## Spreadsheet\n\nA simple spreadsheet-like app which demonstrates use of [`regular-table`](https://github.com/finos/regular-table).\nSupports a simple expression language for cells starting with a `=`\ncharacter, such as `=sum(A2..C4)` for the sum of cell values within the\nrectangular region (A2, C4).\n\n## Data Model\n\nThe `<regular-table>` in question uses the simplest data model of all, the\nhumble 2D `Array`.  We'll start with an empty one in columnar-orientation.\n\n```javascript\nconst NUM_COLUMNS = 200;\nconst NUM_ROWS = 1000;\n\nconst DATA = Array(NUM_COLUMNS)\n    .fill()\n    .map(() => Array(NUM_ROWS).fill());\n```\n\nIn Excel-like fashion though, we'll want _alphabetic_ symbols for\n`column_headers`, so we'll generate a sequence of those using \n`String.fromCharCode()`.\n\n```javascript\nconst DATA_COLUMN_NAMES = generate_column_names();\n\nfunction generate_column_names() {\n    const nums = Array.from(Array(26));\n    const alphabet = nums.map((val, i) => String.fromCharCode(i + 65));\n    let caps = [],\n        i = 1;\n    while (caps.length < NUM_COLUMNS) {\n        caps = caps.concat(alphabet.map((letter) => to_column_name(i, letter)));\n        i++;\n    }\n    return caps;\n}\n\nfunction to_column_name(i, letter) {\n    return Array(i).fill(letter).join(\"\");\n}\n```\n\nThis leads to a simple Virtual Data Model based on `Array.prototype.slice()`.\n\n```javascript\nfunction dataListener(x0, y0, x1, y1) {\n    return {\n        num_rows: DATA[0].length,\n        num_columns: DATA.length,\n        row_headers: Array.from(Array(Math.ceil(y1) - y0).keys()).map((y) => [\n            `${y + y0}`,\n        ]),\n        column_headers: DATA_COLUMN_NAMES.slice(x0, x1).map((x) => [x]),\n        data: DATA.slice(x0, x1).map((col) => col.slice(y0, y1)),\n    };\n}\n```\n\nWe can go ahead and register this `dataListener` with our `<regular-table>`\nnow, since nothing will happen within this cycle of the event loop until\n`draw()` is called.\n\n```javascript\nconst table = document.getElementsByTagName(\"regular-table\")[0];\ntable.setDataListener(dataListener);\n```\n\n## Expression Language\n\nOur expression language features this expansive standard library:\n\n```javascript\nfunction sum(arr) {\n    return flat(arr).reduce((x, y) => parseInt(x) + parseInt(y));\n}\n\nfunction avg(arr) {\n    const x = flat(arr);\n    return x.reduce((x, y) => parseInt(x) + parseInt(y)) / x.length;\n}\n```\n\nIt will also internally use these helper functions:\n\n* `stringify(2, 6)` for cell references `B6`\n* `slice(1, 3, 1, 5)` for rectangular slices `A3..A5`\n\n```javascript\nfunction stringify(x, y) {\n    let txt = DATA[x][y];\n    let num = parseInt(txt);\n    if (isNaN(num)) {\n        num = txt;\n    }\n    return `${num}`;\n}\n\nfunction slice(x0, y0, x1, y1) {\n    return DATA.slice(x0, parseInt(x1) + 1).map((z) =>\n        z.slice(y0, parseInt(y1) + 1)\n    );\n}\n```\n\n```javascript\nfunction col2Idx(x) {\n    return DATA_COLUMN_NAMES.indexOf(x);\n}\n\nfunction flat(arr) {\n    return arr\n        .flat(1)\n        .map((x) => parseInt(x))\n        .filter((x) => !isNaN(x));\n}\n```\n\nThe evaluation engine uses the most powerful, performant and _utilized_ general\npurpose parsing framework available today: `Regex`.\n\n```javascript\nconst RANGE_PATTERN = \"([A-Z]+)([0-9]+)\\\\.\\\\.([A-Z]+)([0-9]+)\";\nconst CELL_PATTERN = \"([A-Z]+)([0-9]+)\";\n```\n\nThe `compile()` function simply removes the leading `=` and applies these\nregular expressions via `replace()` - there is no need to handle nested cases,\nsince neither of these patterns are recursive.\n\n```javascript\nfunction compile(input) {\n    const output = input\n        .slice(1)\n        .replace(\n            new RegExp(RANGE_PATTERN, \"g\"),\n            (_, x0, y0, x1, y1) =>\n                `slice(${col2Idx(x0)}, ${y0}, ${col2Idx(x1)}, ${y1})`\n        )\n        .replace(\n            new RegExp(CELL_PATTERN, \"g\"),\n            (_, x, y) => `stringify(${col2Idx(x)}, ${y})`\n        );\n    console.log(`Compiled '${input}' to '${output}'`);\n    return eval(output);\n}\n```\n\n## User Interaction\n\n```javascript\n\nconst SELECTED_POSITION = {x: 0, y: 0};\n```\n\nWe will need a way to track the `SELECTED_POSITION` in the `regular-table` \nwith the `x` and `y` coordinates currently focused so that we can scroll \nto another distant part of the table and back with our selection preserved.\nWe can default it to the origin.\n\n```javascript\n\nconst updateFocus = () => {\n    const tds = table.querySelectorAll(\"td\");\n    for (const td of tds) {\n        const meta = table.getMeta(td);\n        if (meta.x === SELECTED_POSITION.x && meta.y === SELECTED_POSITION.y) {\n            td.focus();\n        }\n    }\n};\n\ntable.addEventListener(\"click\", (event) => {\n    const meta = table.getMeta(event.target);\n    SELECTED_POSITION.x = meta.x;\n    SELECTED_POSITION.y = meta.y;\n    updateFocus();\n});\n```\n\nWe will use `updateFocus` either directly or by adding it as a style listener below\nto refocus the `td` on our `SELECTED_POSITION` whenever the `regular-table`s `draw()` \ncompletes - due to scrolling or key navigation.\n\nWe'll need to ensure that on click the cell target is selected and has `focus()`.\n\n```javascript\n\ntable.addStyleListener(() => {\n    for (const td of table.querySelectorAll(\"td\")) {\n        td.setAttribute(\"contenteditable\", true);\n    }\n});\n\ntable.addStyleListener(updateFocus);\n\ntable.draw();\n```\n\n`contenteditable` takes care of most of the basics for us, but we'll still\nneed to update our data model when the user evaluates a cell.  Given a cell,\nthis is a simple task of checking the first character for `\"=\"` to determine\nwhether this cell needs to be `eval()`'d, then setting the Array contents of\n`DATA` directly and calling `draw()` to update the `regular-table`.\n\n```javascript\nfunction write(active_cell) {\n    const meta = table.getMeta(active_cell);\n    if (meta) {\n        let text = active_cell.textContent;\n        if (text[0] === \"=\") {\n            text = compile(text);\n        }\n        DATA[meta.x][meta.y] = text;\n        active_cell.blur();\n        clear_highlight();\n        table.draw();\n    }\n}\n```\n\nWe'll call this function whenever the user evaluates a cell, such as when\nthe `return` key is pressed, by looking up the element with focus,\n`document.activeElement`.\n\n```javascript\ntable.addEventListener(\"keypress\", (event) => {\n    const target = document.activeElement;\n    if (event.keyCode === 13) {\n        event.preventDefault();\n        if (event.shiftKey) {\n            moveSelection(target, 0, -1);\n        } else {\n            moveSelection(target, 0, 1);\n        }\n    }\n});\n\ntable.addEventListener(\"keyup\", (event) => {\n    const target = document.activeElement;\n    if (event.keyCode !== 13) {\n        highlight(target);\n    }\n});\n\ntable.addEventListener(\"keydown\", (event) => {\n    const target = document.activeElement;\n    switch (event.keyCode) {\n        // tab\n        case 9:\n            event.preventDefault();\n            if (event.shiftKey) {\n                moveSelection(target, -1, 0);\n            } else {\n                moveSelection(target, 1, 0);\n            }\n            break;\n        // left arrow\n        case 37:\n            moveSelection(target, -1, 0);\n            break;\n        // up arrow\n        case 38:\n            moveSelection(target, 0, -1);\n            break;\n        // right arrow\n        case 39:\n            moveSelection(target, 1, 0);\n            break;\n        // down arrow\n        case 40:\n            moveSelection(target, 0, 1);\n            break;\n    }\n});\n```\n\nThese key handlers also make use of `moveSelection()`, which uses some\nsimple metadata-math to look up the next cell in either the `x` or `y`\ndirection and update the `SELECTED_POSITION` - scrolling the table if \nnecessary and providing a small buffer to the edge of the visible table.\n\n```javascript\nconst SCROLL_AHEAD = 4;\n\nasync function moveSelection(active_cell, dx, dy) {\n    const meta = table.getMeta(active_cell);\n    if (dx !== 0) {\n        if (meta.x + dx < NUM_COLUMNS && 0 <= meta.x + dx) {\n            SELECTED_POSITION.x = meta.x + dx;\n        }\n        if (meta.x1 <= SELECTED_POSITION.x + SCROLL_AHEAD) {\n            await table.scrollToCell(meta.x0 + 2, meta.y0, NUM_COLUMNS, NUM_ROWS);\n        } else if (SELECTED_POSITION.x - SCROLL_AHEAD < meta.x0) {\n            if (0 < meta.x0 - 1) {\n                await table.scrollToCell(meta.x0 - 1, meta.y0, NUM_COLUMNS, NUM_ROWS);\n            } else {\n                await table.scrollToCell(0, meta.y0, NUM_COLUMNS, NUM_ROWS);\n            }\n        }\n    }\n\n    if (dy !== 0) {\n        if (meta.y + dy < NUM_ROWS && 0 <= meta.y + dy) {\n            SELECTED_POSITION.y = meta.y + dy;\n        }\n        if (meta.y1 <= SELECTED_POSITION.y + SCROLL_AHEAD) {\n            await table.scrollToCell(meta.x0, meta.y0 + 1, NUM_COLUMNS, NUM_ROWS);\n        } else if (SELECTED_POSITION.y - SCROLL_AHEAD + 2 < meta.y0) {\n            if (0 < meta.y0 - 1) {\n                await table.scrollToCell(meta.x0, meta.y0 - 1, NUM_COLUMNS, NUM_ROWS);\n            } else {\n                await table.scrollToCell(meta.x0, 0, NUM_COLUMNS, NUM_ROWS);\n            }\n        }\n    }\n    updateFocus();\n}\n```\n\nThere are some simple quality-of-life improvements we can make as well.\nBy default, a `scroll` event such as initiated by the mouse wheel will cause\n`regular-table` to re-render, which will result in the very un-spreadsheet \nlike behavior of resetting a cell which has focus and was in a partial state\nof edit.  To prevent this, we'll call `write()` when a scroll event happens.\n\n```javascript\ntable.addEventListener(\"scroll\", () => {\n    write(document.activeElement);\n});\n```\n\nIn fact, let's go ahead and do this anytime focus is lost on an element within\nour `<regular-table>`.\n\n```javascript\ntable.addEventListener(\"focusout\", (event) => {\n    write(event.target);\n});\n```\n\n## Cell Highlighting\n\nWouldn't it be cool if the spreadsheet highlighted the cells that would be\nincluding in a selection, _as you type?_  It's no longer a far-fetched dream,\nrather `spredsheet.md` already does this!\n\nThe `highlight()` function is similar to `compile()`, except in this case, the\ncompiler output is `class` attributes on `<td>` elements.\n\n```javascript\nasync function highlight(active_cell) {\n    clear_highlight();\n    const text = active_cell.textContent;\n    const meta = table.getMeta(active_cell);\n\n    for (const [x, y] of cell_iter(CELL_PATTERN, text)) {\n        paint_highlight(x + 1, y, meta);\n    }\n\n    for (const [x0, y0, x1, y1] of cell_iter(RANGE_PATTERN, text)) {\n        for (let i = x0; i <= x1; i++) {\n            for (let j = y0; j <= y1; j++) {\n                paint_highlight(i + 1, j, meta);\n            }\n        }\n    }\n}\n```\n\nThere are three cell-level helper functions - `clear_highlight()` and\n`paint_highlight()` remove and apply the cell highlighting (respectively),\nand `cell_iter()` generator produces a sequence of match cells, translated\ninto `regular-table` Metadata coordinates (`x`, `y`).\n\n```javascript\nfunction clear_highlight() {\n    for (const td of table.querySelectorAll(\"td.highlight\")) {\n        td.classList.remove(\"highlight\");\n    }\n}\n\nfunction* cell_iter(patt, text) {\n    let match;\n    let regex = new RegExp(patt, \"g\");\n    while ((match = regex.exec(text)) !== null) {\n        yield match\n            .slice(1)\n            .map((x, i) => (i % 2 === 0 ? col2Idx(x) : parseInt(x)));\n    }\n}\n\nfunction paint_highlight(x, y, meta) {\n    const tr = table.querySelector(\"tbody\").children[y - meta.y0];\n    const td = tr.children[x - meta.x0];\n    td.classList.add(\"highlight\");\n}\n```\n\n## HTML and CSS\n\nThere is not much elaborate about the HTML setup for this `regular-table`.\n\n```html\n<regular-table></regular-table>\n```\n\nHowever, we'd like an Excel-like User Experience, so let's liven up the default\ntheme with a trendy grid, which we can easily do purely via CSS, since these\ncells are always `<td>` elements.  We're also going to limit the cells to\n`22px` - they need to be big enough to click on, and as they start empty, they\nmay end up quite narrow.\n\n```css\ntd {\n    outline: none;\n    border-right: 1px solid #eee;\n    border-bottom: 1px solid #eee;\n    min-width: 22px;\n}\n```\n\nWe'll do the same for `row_headers` and `column_headers` to separate them from\nthe editable cells.\n\n```css\nth {\n    border-right: 1px solid #eee;\n}\n```\n\nThe special class `highlight` is used by the `highlight()` function to paint\ncells which will be returned by a cell or range query in an expression.\n\n```css\n.highlight {\n    background-color: rgba(0,0,155, 0.1);\n}\n```\n\n## Appendix (Dependencies)\n\n```html\n<script src=\"/dist/umd/regular-table.js\"></script>\n<link rel='stylesheet' href=\"/dist/css/material.css\">\n```\n\n```block\nlicense: apache-2.0\n```\n\n"]}