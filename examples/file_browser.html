<!--

   Copyright (c) 2020, the Regular Table Authors.

   This file is part of the Regular Table library, distributed under the terms of
   the Apache License 2.0.  The full license can be found in the LICENSE file.

-->

<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <script src="../umd/regular-table.js"></script>
    <link rel='stylesheet' href="../css/material.css">
</head>

<body>

    <regular-table></regular-table>

    <script>
        const NUM_ROWS = 100;
        const NUM_DIR = 10;
        const NUM_FILE = NUM_ROWS - NUM_DIR;

        const COLUMN_NAMES = ['modified', 'writable'];
        const SCHEMA = {'name': 'string', 'modified': 'date', 'writable': 'string'};

        const _contents_cache = new Map();
        function getContents(path, expand) {
            // infinite recursive mock contents
            let contents;
            if (_contents_cache.has(path)) {
                contents = _contents_cache.get(path);
            } else {
                contents = {path, modified: new Date(1000), writable: false};
                _contents_cache.set(path, contents);
            }

            if (!expand || 'contents' in contents) {
                return contents;
            }

            let sub = []
            for (let i = 0; i < NUM_ROWS; i ++) {
                sub.push({
                    path: [...path, i < NUM_DIR ? `${i}/` : `${i}.txt`],
                    modified: new Date(1000*86400*i),
                    writable: false,
                });
            }

            contents.contents = sub;
            return contents;
        }

        function insertContents(rix, arr) {
            const contents = getContents(arr[rix].path, true);
            arr.splice(rix, 0, ...contents.contents);
        }

        function popContents(rix, arr) {
            const {path} = arr[rix]
            const contents = getContents(path, true);

            // pop out the contents of the collapsed node and any expanded subnodes
            let npop = contents.contents.length;
            let check_ix = rix + 1 + npop;
            while (arr[check_ix++].path.length > path.length) {
                npop++;
            }

            arr.splice(rix + 1, npop);
        }

        let rows = getContents([], true).contents;

        async function file_browser_model(start_col, start_row, end_col, end_row) {
            const data = [];
            for (let cix = start_col; cix < end_col; cix ++) {
                const name = COLUMN_NAMES[cix];
                data.push(
                    rows.slice(start_row, end_row).map(c => c[name])
                );
            }

            return {
                num_rows: rows.length,
                num_columns: COLUMN_NAMES.length,
                column_indices: COLUMN_NAMES.map(col => [col]),
                row_indices: rows.slice(start_row, end_row).map(c => c['path']),
                data,
            };
        }

        // for tree support
        file_browser_model.collapse = rix => {
            popContents(rix, rows);
        };
        file_browser_model.expand = rix => {
            insertContents(rix + 1, rows);
        }

        const table = document.getElementsByTagName('regular-table')[0];
        table.setDataModel(file_browser_model).then(() => {
            table._view_cache.config = {
                row_pivots: ['name'],
                column_pivots: []
            };
        });
    </script>

</body>

</html>
